fn rotate_string(s: String, n: isize) -> String {

    let len = s.len() as isize;
    let shift = ((n % len) + len) % len;
    let part1 = &s[(len - shift) as usize..];
    let part2 = &s[..(len - shift) as usize];
    
    format!("{}{}", part1, part2)
}

fn main() {
    let s = "abcdefgh".to_string();
    let shifts = [
        (0, "abcdefgh"), (8, "abcdefgh"), (-8, "abcdefgh"),
        (1, "habcdefg"), (2, "ghabcdef"), (10, "ghabcdef"),
        (-1, "bcdefgha"), (-2, "cdefghab"), (-10, "cdefghab"),
    ];
    
    for (n, expected) in shifts {
        let result = rotate_string(s.clone(), n);
        println!("Зсув: {}, Очікувано: {}, Отримано: {}", n, expected, result);
        assert_eq!(result, expected);
    }
}

Спочатку я створив функцію rotate_string, яка приймає рядок s і число n, що вказує на кількість зсувів.

Визначив змінну len, яка зберігає довжину рядка. Довжина потрібна для того, щоб обробляти зміщення, яке може бути більше за кількість символів у рядку.

Далі я обчислив реальне зміщення, використовуючи формулу ((n % len) + len) % len. Це потрібно, щоб коректно працювати зі зсувами, які виходять за межі довжини рядка, або з негативними зсувами.
                                            
Наприклад, зміщення на -1 означає, що потрібно зсунути рядок на один символ вліво, а не обробляти це як неправильний індекс.

Потім я розбив рядок на дві частини. Спочатку взяв частину від кінця рядка до точки зсуву за допомогою &s[(len - shift) as usize..], а потім початок рядка до цієї ж точки за допомогою &s[..(len - shift) as usize]. Це дозволяє обміняти місцями дві частини рядка.

Я об'єднав ці дві частини в новий рядок за допомогою format!, що створює остаточний результат.

У функції main() я використав кілька прикладів зміщення рядка і перевірив, чи результат співпадає з очікуваним. Також вивів кожен результат, щоб побачити, як рядок змінюється після зсуву.
